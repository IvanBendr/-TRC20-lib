# -TRC20-lib
@@ -1,35 +1,42 @@
основательность прагмы ^ 0,4.23;
прочность прагмы > = 0,4,23 < 0,6,0 ;

импорт "openzeppelin-solidity / контракты / токен / ERC20 / MintableToken.sol";
import "./tokens/TRC20/TRC20Detailed.sol";
import "./tokens/TRC20/TRC20.sol";
import "./roles/MinterRole.sol";

контракт HoraToken является MintableToken {
контракт HoraToken является TRC20, TRC20Detailed, MinterRole {
    uint8 частная константа _decimals = 6;
    uint256 частная константа _maxMint = 100000000 * (10 ** uint256 (_decimals)); // 100 миллионов
    uint256 частная константа _cap = _maxMint * 120; // 12 миллиардов кепок, 10 лет чеканки в оценке
    uint частная константа _mintInterval = 60 * 60 * 24 * 25; // 25 дней минимальный интервал между чеканками - сек * мин * ч * день
    uint private _lastMint = 0;

	строка публичная константа name = "Hora Token";
	строка общедоступная постоянная символ = "HORA";
	uint8 открытая десятичная дробь = 6;
	uint256 частная константа maxMint = 1000000 * 100000000; // 100M на солнце
	uint256 публичная константа mintTotalLimit = 1000000 * 100000000 * 120; // 12b max minting, 10 лет в оценке
	uint частная константа mintInterval = 60 * 60 * 24 * 25; // 25 дней
	uint private lastMint = 0;
    конструктор ()
        TRC20Detailed ("Hora Token", "HORA", _decimals)
        TRC20 ()
        общественности
    {}

	функция мята (
		Отправить,
		uint256 _amount
	)
	общественности
	hasMintPermission
	canMint
	возвращается (бул)
	{
		_amount = _amount * 1000000;
		require (_amount <= maxMint, "AMOUNT NOT ALLOWED");
		require (сейчас - mintInterval> lastMint, "TIME RANGE LOW");
		require (totalSupply_ <mintTotalLimit, "TITAL SUPPLY LIMIT HIT");
		totalSupply_ = totalSupply_.add (_amount);
		balances [_to] = balances [_to] .add (_amount);
		испускать монетный двор (_to, _amount);
		передать перевод (адрес (0), _to, _amount);
		lastMint = сейчас;
		вернуть истину;
	}
    function cap () public pure return (uint256) {
        возврат _cap;
    }

    функция lastMintTime () публичное представление return (uint) {
        вернуть _lastMint;
    }

    function mintCooldownMinutes () публичное представление return (uint) {
        require (сейчас - _mintInterval <_lastMint, "MINT: READY");
        return ((_mintInterval - (сейчас - _lastMint)) / 60 + 1);
    }

    функция mint (адрес, значение uint256) public onlyMinter возвращает (bool) {
        uint256 _value = значение * (10 ** uint256 (_decimals));
        require (_value <= _maxMint, "MINT: AMOUNT NOT ALLOWED");
		require (сейчас - _mintInterval> _lastMint, "MINT: TIME RANGE LOW");
        require (totalSupply (). add (_value) <= _cap, "MINT: ПОЛНЫЙ ХИТ ПРЕДЛОЖЕНИЯ ПОДАЧИ");
        _mint (to, _value);
        _lastMint = сейчас;
        вернуть истину;
    }
} 
 10  контракты / Migrations.sol 
@@ -1,17 +1,17 @@
Прагма солидность ^ 0,4. 18 ;
Прагма солидности > = 0,4. 23 <0,6,0 ;

Миграции по контракту {
  адрес публичного владельца;
  uint public last_completed_migration;

  ограниченный модификатор () {
    if (msg.sender == владелец) _;
  }

  constructor () public {
    владелец = msg.sender;
  }

  ограниченный модификатор () {
    if (msg.sender == владелец) _;
  }

  функция setCompleted (uint complete) публично ограничена {
    last_completed_migration = завершено;
  }
 43  контракты / роли / MinterRole.sol 
@@ -0,0 +1,43 @@
прочность прагмы> = 0,4,23 <0,6,0;

import "./Roles.sol";

контракт MinterRole {
    использование ролей для Roles.Role;

    событие MinterAdded (адрес проиндексированного аккаунта);
    событие MinterRemoved (адрес проиндексированного аккаунта);

    Роли. Роль частных _minters;

    constructor () internal {
        _addMinter (msg.sender);
    }

    только модификаторMinter () {
        требуется (isMinter (msg.sender));
        _;
    }

    функция isMinter (адрес учетной записи) публичное представление возвращает (bool) {
        return _minters.has (account);
    }

    функция addMinter (адрес учетной записи) public onlyMinter {
        _addMinter (счет);
    }

    функция renounceMinter () public {
        _removeMinter (msg.sender);
    }

    функция _addMinter (адрес учетной записи) internal {
        _minters.add (счет);
        эмитировать MinterAdded (аккаунт);
    }

    функция _removeMinter (адрес учетной записи) internal {
        _minters.remove (счет);
        эмитировать MinterRemoved (аккаунт);
    }
}
 40  контракты / роли / Roles.sol 
@@ -0,0 +1,40 @@
прочность прагмы> = 0,4,23 <0,6,0;

/ **
 * @title Роли
 * @dev Библиотека для управления адресами, назначенными для роли.
 * /
Роли библиотеки {
    struct Role {
        отображение (адрес => bool) канала-носителя;
    }

    / **
     * @dev дать учетной записи доступ к этой роли
     * /
    функция добавить (роль хранения роли, адрес учетной записи) внутренняя {
        требовать (аккаунт! = адрес (0));
        требуют (! имеет (роль, учетная запись));

        role.bearer [account] = true;
    }

    / **
     * @dev удалить доступ учетной записи к этой роли
     * /
    функция удаления (роль хранилища ролей, учетная запись адреса) внутренняя {
        требовать (аккаунт! = адрес (0));
        требовать (имеет (роль, учетная запись));

        role.bearer [account] = false;
    }

    / **
     * @dev проверить, есть ли у учетной записи эту роль
     * @return bool
     * /
    функция имеет (роль хранения роли, адрес учетной записи) возвращает внутреннее представление (bool) {
        требовать (аккаунт! = адрес (0));
        вернуть role.bearer [account];
    }
}
 34  контракты / лексемы / TRC20 / ITRC20.sol 
@@ -0,0 +1,34 @@
прочность прагмы> = 0,4,23 <0,6,0;

/ **
 * Интерфейс @title TRC20 (совместим с интерфейсом ERC20)
 * @dev см. https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md.
 * /
интерфейс ITRC20 {
    функция totalSupply () возвращает внешний вид (uint256);

    функция balanceOf (address who) возвращает внешний вид (uint256);

    функциональное пособие (адрес владельца, адрес спонсора)
    внешний вид возвращается (uint256);

    передача функции (адрес, значение uint256) внешние возвраты (bool);

    функция подтверждения (адрес спонсора, значение uint256)
    внешние возвраты (bool);

    функция TransferFrom (адрес от, адрес до, значение uint256)
    внешние возвраты (bool);

    Передача события (
        адрес индексируется с,
        адрес индексируется по адресу,
        значение uint256
    );

    Утверждение события (
        адрес индексируется владельцем,
        адрес индексируется спонсором,
        значение uint256
    );
}
 207  контракты / лексемы / TRC20 / TRC20.sol 
@@ -0,0 +1,207 @@
прочность прагмы> = 0,4,23 <0,6,0;

import "./ITRC20.sol";
import "../../utils/SafeMath.sol";

/ **
 * @title Стандартный токен TRC20 (совместим с токеном ERC20)
 *
 * @dev Реализация базового стандартного токена.
 * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md
 * Первоначально на основе кода FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 * /
контракт TRC20 - это ITRC20 {
    использование SafeMath для uint256;

    отображение (адрес => uint256) частные _balances;

    mapping (address => mapping (address => uint256)) private _allowed;

    uint256 private _totalSupply;

    / **
     * @dev Общее количество существующих токенов
     * /
    функция totalSupply () возвращает публичное представление (uint256) {
        вернуть _totalSupply;
    }

    / **
     * @dev Получает баланс указанного адреса.
     * @param owner Адрес для запроса баланса.
     * @return Uint256, представляющий сумму, принадлежащую переданному адресу.
     * /
    функция balanceOf (владелец адреса) возвращает публичное представление (uint256) {
        вернуть _balances [владелец];
    }

    / **
     * Функция @dev для проверки количества токенов, которые владелец разрешил спонсору.
     * @param owner address Адрес, которому принадлежат средства.
     * @param spender address Адрес, на который будут потрачены средства.
     * @return A uint256, указывающий количество токенов, все еще доступных для спонсора.
     * /
    функциональное пособие (
        владелец адреса,
        адрес спонсора
    )
    общественности
    Посмотреть
    возвращает (uint256)
    {
        вернуть _allowed [владелец] [спонсор];
    }

    / **
     * @dev Перенос токена на указанный адрес
     * @param to Адрес для передачи.
     * @param value Сумма перевода.
     * /
    функция передачи (адрес, значение uint256) публичные возвраты (bool) {
        _transfer (msg.sender, to, value);
        вернуть истину;
    }

    / **
     * @dev Одобрить переданный адрес, чтобы потратить указанное количество токенов от имени msg.sender.
     * Помните, что изменение пособия с помощью этого метода несет в себе риск того, что кто-то может использовать оба старых
     * и новое пособие при неудачном заказе транзакции. Одно возможное решение, чтобы смягчить это
     * условие гонки - сначала уменьшить допуск спонсора до 0, а затем установить желаемое значение:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender Адрес, на который будут потрачены средства.
     * @param value Количество токенов, которые нужно потратить.
     * /
    функция Approve (адрес спонсора, значение uint256) публичные результаты (bool) {
        требовать (спонсор! = адрес (0));

        _allowed [msg.sender] [spender] = значение;
        emit Approval (msg.sender, spender, value);
        вернуть истину;
    }

    / **
     * @dev Перенос токенов с одного адреса на другой
     * @param from address Адрес, с которого вы хотите отправить токены с
     * @param to address Адрес, на который вы хотите передать
     * @param value uint256 количество передаваемых токенов
     * /
    функция TransferFrom (
        адрес от,
        Отправить,
        значение uint256
    )
    общественности
    возвращается (бул)
    {
        _allowed [from] [msg.sender] = _allowed [from] [msg.sender] .sub (значение);
        _transfer (от, до, значение);
        вернуть истину;
    }

    / **
     * @dev Увеличьте количество токенов, которые владелец разрешил спонсору.
     * Утверждение должно вызываться, когда это разрешено _ [_ spender] == 0. Для увеличения
     * разрешенное значение лучше использовать эту функцию, чтобы избежать 2 вызовов (и ждать, пока
     * первая транзакция добыта)
     * От MonolithDAO Token.sol
     * @param spender Адрес, на который будут потрачены средства.
     * @param AddedValue Количество токенов, на которые нужно увеличить скидку.
     * /
    функция увеличенияAllowance (
        адрес спонсора,
        uint256 добавлено значение
    )
    общественности
    возвращается (бул)
    {
        требовать (спонсор! = адрес (0));

        _allowed [msg.sender] [spender] = (
        _allowed [msg.sender] [транжира] .add (addedValue));
        emit Approval (msg.sender, spender, _allowed [msg.sender] [spender]);
        вернуть истину;
    }

    / **
     * @dev Уменьшите количество токенов, которые владелец разрешил спонсору.
     * Одобрить следует вызывать, когда это разрешено _ [_ spender] == 0. Уменьшить
     * разрешенное значение лучше использовать эту функцию, чтобы избежать 2 вызовов (и ждать, пока
     * первая транзакция добыта)
     * От MonolithDAO Token.sol
     * @param spender Адрес, на который будут потрачены средства.
     * @param subtractedValue Количество токенов, на которые уменьшается скидка.
     * /
    функция lowerAllowance (
        адрес спонсора,
        uint256 вычитаемое значение
    )
    общественности
    возвращается (бул)
    {
        требовать (спонсор! = адрес (0));

        _allowed [msg.sender] [spender] = (
        _allowed [msg.sender] [транжира] .sub (subtractedValue));
        emit Approval (msg.sender, spender, _allowed [msg.sender] [spender]);
        вернуть истину;
    }

    / **
     * @dev Передача токена для указанных адресов
     * @param from Адрес для передачи.
     * @param to Адрес для передачи.
     * @param value Сумма перевода.
     * /
    функция _transfer (адрес от, адрес до, значение uint256) внутренняя {
        требовать (до! = адрес (0));

        _balances [from] = _balances [from] .sub (значение);
        _balances [to] = _balances [to] .add (значение);
        испустить Transfer (от, до, значение);
    }

    / **
     * @dev Внутренняя функция, которая меняет количество токена и присваивает его
     * аккаунт. Это заключает в себе модификацию весов, так что
     * правильные события испускаются.
     * @param account Учетная запись, которая будет получать созданные токены.
     * @param value Количество, которое будет создано.
     * /
    функция _mint (адрес учетной записи, значение uint256) внутренняя {
        требовать (аккаунт! = адрес (0));

        _totalSupply = _totalSupply.add (значение);
        _balances [account] = _balances [account] .add (значение);
        отправить перевод (адрес (0), счет, стоимость);
    }

    / **
     * @dev Внутренняя функция, которая записывает количество токена данного
     * учетная запись.
     * @param account Аккаунт, токены которого будут сожжены.
     * @param value Количество, которое будет сожжено.
     * /
    функция _burn (адрес счета, значение uint256) внутренняя {
        требовать (аккаунт! = адрес (0));

        _totalSupply = _totalSupply.sub (значение);
        _balances [account] = _balances [account] .sub (значение);
        эмитировать Transfer (аккаунт, адрес (0), стоимость);
    }

    / **
     * @dev Внутренняя функция, которая записывает количество токена данного
     * счет, вычитая из пособия отправителя указанный счет. Использует
     * функция внутреннего сжигания.
     * @param account Аккаунт, токены которого будут сожжены.
     * @param value Количество, которое будет сожжено.
     * /
    функция _burnFrom (адрес счета, значение uint256) внутренняя {
        // Должно быть принято https://github.com/OpenZeppelin/zeppelin-solidity/issues/707,
        // эта функция должна выдавать событие с обновленным утверждением.
        _allowed [account] [msg.sender] = _allowed [account] [msg.sender] .sub (
            стоимость);
        _burn (счет, стоимость);
    }
}

 26  контракты / лексемы / TRC20 / TRC20Burnable.sol 
@@ -0,0 +1,26 @@
прочность прагмы> = 0,4,23 <0,6,0;

import "./TRC20.sol";

/ **
 * @title Burnable Token
 * @dev Токен, который можно необратимо сжечь (уничтожить).
 * /
договор TRC20Burnable является TRC20 {
    / **
     * @dev Сжигает определенное количество токенов.
     * @param value Количество токена, который нужно сжечь.
     * /
    функция burn (значение uint256) public {
        _burn (msg.sender, value);
    }

    / **
     * @dev Сжигает определенное количество токенов с целевого адреса и декрементов.
     * @param from address Адрес, с которого вы хотите отправить токены с
     * @param value uint256 Количество токена, который нужно сжечь
     * /
    функция burnFrom (адрес от, значение uint256) public {
        _burnFrom (от, значение);
    }
}
 28  контракты / лексемы / TRC20 / TRC20Capped.sol 
@@ -0,0 +1,28 @@
прочность прагмы> = 0,4,23 <0,6,0;

import "./TRC20Mintable.sol";

/ **
 * @title Закрытый токен
 * @dev Mintable токен с крышкой токена.
 * /
контракт TRC20Capped является TRC20Mintable {
    uint256 private _cap;

    конструктор (uint256 cap) public {
        требовать (cap> 0);
        _cap = cap;
    }

    / **
     * @ вернуть колпачок для чеканки жетонов.
     * /
    функция cap () публичное представление возвращает (uint256) {
        возврат _cap;
    }

    функция _mint (адрес учетной записи, значение uint256) внутренняя {
        require (totalSupply (). add (value) <= _cap);
        super._mint (account, value);
    }
}
 46  контракты / лексемы / TRC20 / TRC20Detailed.sol 
@@ -0,0 +1,46 @@
прочность прагмы> = 0,4,23 <0,6,0;

import "./TRC20.sol";

/ **
 * @title TRC20Детальный токен
 * @dev Десятичные дроби предназначены только для визуализации.
 * Все операции выполняются с использованием наименьшего и неделимого токена,
 * Как и на TRON, все операции выполняются на солнце.
 *
 * Пример наследует от базовой реализации TRC20, но может быть изменен на
 * распространяются из других токенов на основе ITRC20:
 * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1536
 * /
контракт TRC20Detailed является TRC20 {
    строка private _name;
    строка приватная _symbol;
    uint8 private _decimals;

    конструктор (имя памяти строки, символ памяти строки, десятичные числа uint8) public {
        _name = имя;
        _symbol = символ;
        _decimals = десятичные дроби;
    }

    / **
     * @ вернуть имя токена.
     * /
    функция name () публичное представление возвращает (строковая память) {
        возврат _имя;
    }

    / **
     * @ вернуть символ токена.
     * /
    функция symbol () публичное представление возвращает (строковая память) {
        вернуть _символ;
    }

    / **
     * @ вернуть количество десятичных знаков токена.
     * /
    функция decimals () публичное представление возвращает (uint8) {
        вернуть _decimals;
    }
}
 21  контракты / лексемы / TRC20 / TRC20Mintable.sol 
@@ -0,0 +1,21 @@
прочность прагмы> = 0,4,23 <0,6,0;

import "./TRC20.sol";
import "../../roles/MinterRole.sol";

/ **
 * @title TRC20Mintable
 * @dev TRC20 логика чеканки
 * /
контракт TRC20Mintable это TRC20, MinterRole {
    / **
     * @dev Функция чеканить токены
     * @param to Адрес, который получит отчеканенные токены.
     * @param value Количество токенов в монетном дворе.
     * @return Логическое значение, указывающее, была ли операция успешной.
     * /
    функция mint (адрес, значение uint256) public onlyMinter возвращает (bool) {
        _mint (до, значение);
        вернуть истину;
    }
}
 66  контракты / Utils / SafeMath.sol 
@@ -0,0 +1,66 @@
прочность прагмы> = 0,4,23 <0,6,0;

/ **
 * @title SafeMath
 * @dev Математические операции с проверками безопасности, которые возвращаются при ошибке
 * /
библиотека SafeMath {

    / **
     * @dev Умножает два числа, возвращается при переполнении.
     * /
    function mul (uint256 a, uint256 b) внутренние чистые возвраты (uint256) {
        // Газовая оптимизация: это дешевле, чем требовать, чтобы «а» не было нулем, а
        // выгода теряется, если 'b' также проверяется.
        // См .: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            вернуть 0;
        }

        uint256 c = a * b;
        требовать (с / а == б);

        возврат с;
    }

    / **
     * @dev Целочисленное деление двух чисел, усекающих частное, возвращает деление на ноль.
     * /
    функция div (uint256 a, uint256 b) внутренние чистые возвраты (uint256) {
        требовать (b> 0); // Солидность только автоматически устанавливается при делении на 0
        uint256 c = a / b;
        // assert (a == b * c + a% b); // Нет случая, когда это не выполняется

        возврат с;
    }

    / **
     * @dev Вычитает два числа, возвращается при переполнении (т. е. если вычитаемое больше, чем наименьшее).
     * /
    функция sub (uint256 a, uint256 b) внутренние чистые возвраты (uint256) {
        требовать (b <= a);
        uint256 c = a - b;

        возврат с;
    }

    / **
     * @dev Добавляет два числа, возвращается при переполнении.
     * /
    функция add (uint256 a, uint256 b) внутренние чистые возвраты (uint256) {
        uint256 c = a + b;
        требуют (с> = а);

        возврат с;
    }

    / **
     * @dev Делит два числа и возвращает остаток (целое число без знака по модулю),
     * возвращается при делении на ноль.
     * /
    function mod (uint256 a, uint256 b) внутренние чистые возвраты (uint256) {
        требовать (b! = 0);
        вернуть% b;
    }
}

 444  current_abi.json 
Этот файл был удален.

 31  estimate_deployment.js 
Этот файл был удален.

 493  horatoken_flat.sol 
Большие различия не отображаются по умолчанию.

 115  output.txt 
Этот файл был удален.

 7562  Пакет-lock.json 
Большие различия не отображаются по умолчанию.

 10  package.json 
@@ -12,19 +12,15 @@
  },
  " originalAuthors " : " трюфель " ,
  " автор " : {
    " имя " : " Франческо Сулло " ,
    " электронная почта " : " francesco@sullo.co "
    " имя " : " Горан Алексич " ,
    " электронная почта " : " goran@horagames.com "
  },
  « лицензия » : « MIT » ,
  " devDependencies " : {
    « мел » : « ^ 2.4.1 » ,
    " lite-сервер " : " ^ 2.4.0 "
  },
  " зависимости " : {
    " openzeppelin-solidity " : " ^ 1.10.0 " ,
    «время регенерации » : « ^ 0.13.2 » ,
    " truffle-hdwallet-provider " : " ^ 1.0.0-web3one.5 " ,
    " truffle-hdwallet-provider-privkey " : " ^ 1.0.3 " ,
    " поставщик трюфельных книг " : " ^ 1.0.1 "
    " openzeppelin-solidity " : " ^ 2.3.0 "
  }
}
 25  Тест / TestMetacoin.sol 
Этот файл был удален.

 63  тест / metacoin.js 
Этот файл был удален.

 1  tronbox.js 
@@ -1,6 +1,7 @@
постоянный  порт  =  процесс . окр . HOST_PORT  ||  9090

модуль . экспорт  = {
    useZeroFourCompiler :  true ,
    сети : {
        разработка : {
            privateKey :  процесс . окр . PRIVATE_KEY_DEV ,
 36  трюфель-config.js 
@@ -34,28 +34,28 @@
//    }
// };

const  регенераторRuntime  =  требуется ( « регенератор-время выполнения » );
//  const регенераторRuntime = требуется ("регенератор-время выполнения");

var LedgerWalletProvider =  require ( " truffle-ledger -provider " );
var infura_apikey =  ' ' ; // установить ключ API Infura
var ledgerOptions = {
  networkId :  3 , // ropsten testnet
  accountOffset :  0  // мы используем первый адрес
};
//  var LedgerWalletProvider = require ("truffle-ledger-provider");
//  var infura_apikey = ''; // установить ключ API Infura
//  var ledgerOptions = {
//    networkId: 3, // ropsten testnet
//    accountOffset: 0 // мы используем первый адрес
//  };
модуль . экспорт  = {
  составители : {
    solc : {
      версия :  ' ^ 0.5. 2 ' , // Версия или ограничение - напр. "^ 0.5.0"
      версия :  ' 0.5. 4 ' , // Версия или ограничение - напр. "^ 0.5.0"
    }
  },
  сети : {
    Ропстен : {
      провайдер :  новый  LedgerWalletProvider (
        ledgerOptions,
        " https://ropsten.infura.io/ "  + infura_apikey
      ),
      network_id :  3 ,
      газ :  4600000
    }
  }
  //  сети: {
  //    ropsten: {
  //      провайдер: новый LedgerWalletProvider (
  //        ledgerOptions,
  //        "https://ropsten.infura.io/" + infura_apikey
  //      ),
  //      network_id: 3,
  //      газ: 4600000
  //    }
  //  }
};
